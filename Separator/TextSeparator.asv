classdef TextSeparator
    methods(Static)
        function imresult = preprocess(image, agresja)

        % Przenieś obraz na odcienie szarości
        im = rgb2gray(image) ;

        agresja = ceil(agresja{1} / 100 * 5);
        
        % Odszumianie w dziedzinie obrazu skali szarości
        % im = medfilt2(im);
        
        % figure
        % imshow(im)
        
        % Progowanie adaptacyjne daje lepsze wyniki dla zanieczyszczonego tekstu
        T = adaptthresh(im, 0.99);
        im = ~imbinarize(im,T);


        
        % Wstępne odszumianie i usuwanie artefaktów
        im = imclearborder(im);
        im = imopen(im, ones(agresja));
        im = imclose(im, ones(agresja));
        % im = medfilt2(im);
        
        % Mocniejsze odszumianie z użyciem regionprops
        
        % props = regionprops(im,'Area');
        % S = cat(1, props.Area);
        % 
        % meanS = mean(S);
        % stdev = std(S);
        % 
        % label = bwlabel(im);
        % 
        % for i = 1:max(label, [], 'all')
        %     a = regionprops(label == i, 'Area');
        %     if abs(a.Area - meanS) / stdev > 1
        %         label(label==i) = 0;
        %     end
        % end
        % 
        % im = (label > 0);
        
        % figure
        % imshow(im)

        % Wydobycie paragrafów tekstu z obrazka (nowy parametr?)

        thick = bwmorph(, 'thicken', 5);
        thick = imfill(thick, "holes");
        thick = imclose(thick, ones(5));
        thick = imfill(thick, "holes");
        
        imresult = thick;
        
        
        end

        function lines = paragraphProcess(paragraphImage)
            
            l = bwlabel(paragraphImage);
            
            % figure
            % imshow(im2);

            % Szukamy kropek, kropki są be
            areasUnfiltered = regionprops(paragraphImage, 'Area');
            areasUnfiltered = cat(1, areasUnfiltered.Area);
            
            avgArea = mean(areasUnfiltered);
            Areadev = std(areasUnfiltered);
            
            outlier = (areasUnfiltered - avgArea)./ Areadev; % Znak jest nam potrzebny, bo innym rodzajem artefaktu są wieloznaki!!
            
            t = -1.5; % Metodad NaOkowa

            % Find zwraca indeksy elementow ktore sa niezerowe
            outidx = find(outlier < t);

            % Backup który zawiera kropki przed operacją
            dots = l;
            
            % Usuwamy wszystkie wiersze ktore uznajemy za nietypowe
            l(ismember(l,outidx)) = 0; % usuwamy z obrazu binarnego
            dots(~ismember(dots,outidx)) = 0; % usuwamy wszystko poza kropkami

            % figure
            % imshow(dots)
            
            
            dotfree = l > 0;

            % figure
            % imshow(dotfree)

            % Mamy odszumiony, odkropkowany obraz jednego paragrafu, można
            % zacząć szukać linii

            labels = bwlabel(dotfree);
            properties = regionprops(labels, 'Centroid', 'BoundingBox');
           
            heights = cat(1,properties.BoundingBox);
            avgHeights = ceil(mean(heights(:,4)) / 2);
            
            % Musimy operowac na liczbach calkowitych
            yInts = round(cat(1,properties.Centroid));
            yInts = yInts(:,2);
            
            largestY = max(yInts,[],'all');
            
            % Sprawdzamy jakie wartosci y istnieja wsrod naszych centroidow
            % Nastepnie przeprowadzamy dylatacje na osi wysokosci, co rowna sie
            % zlaczeniu pobliskich sobie w y znakow w jeden obszar
            yArray = ismember(1:largestY, yInts);
            yArray = imdilate(yArray,ones(avgHeights));
            yArray = bwlabel(yArray);
            
            
            % figure;
            % plot(yArray);
            
            % Nakladamy obszary linii na nowy obraz wynikowy
            k = zeros(size(labels));
            
            for i = 1:size(yInts,1)
                sub = (labels == i) .* yArray(yInts(i));
                k = k + sub;
            end

            linesorig = k;
            
            
            % Grupujemy kropki do linii, kropka wskakuje do linii w której
            % jest na osiach y liter wielkich
            for line = 1:max(k, [], 'all')

                lineim = k == line;
                lineim = bwlabel(lineim);

                % figure
                % imshow(label2rgb(lineim,'jet','black','shuffle') )

                boxes = cat(1,regionprops(lineim, 'BoundingBox').BoundingBox);
                [minY, minIndex] = min(boxes(:,2),[],'all');
                minY = floor(minY);
                maxY = minY + boxes(minIndex,4);


                k(minY:maxY,:) = line;
            end
            
            dots = bwlabel(dots > 0);
            dfilt = zeros(size(dots));

            for i = 1:size(dots,1)
                sub = (dots == i) .* k;
                dfilt = dfilt + sub;
            end

            % Mamy dwa obrazy wynikowe - obraz z liniami oraz kropkami
            % Label kropek odpowiada labelom tych linii do których naleza

            linesfull = linesorig + dfilt;

            % 
            % figure
            % imshow(label2rgb(linesfinal,'jet','black','shuffle') )

            boxes = cat(1,regionprops(linesorig, 'BoundingBox').BoundingBox);
            
            compositedLetters = zeros(size(linesfull));

            letterLabel = 1;

            for line = 1:max(linesorig, [], "all")

                lineim = imcrop(linesorig, boxes(line, :));
                lineim = bwlabel(lineim);

                linebox = boxes(line, :);
                
                % figure
                % imshow(label2rgb(lineim,'jet','black','shuffle'));

                lineprops = regionprops(lineim, 'BoundingBox', 'Image');
                letterboxes = cat(1,lineprops.BoundingBox);

                for letter = 1:max(lineim, [], "all")

                    % Przygotowujemy obrazek
                    % Szerokość litery
                    % Wysokość linii
                    % Osadzony na y linii, x litery w linii + x linii
                    letterboxLocal = letterboxes(letter, :);
                    letterbox = letterboxLocal;
                    letterbox(1) = floor(letterbox(1) + linebox(1));
                    letterbox(2) = floor(linebox(2));
                    letterbox(4) = linebox(4);

                    letterImage = imcrop(linesorig, letterbox) + imcrop(dfilt, letterbox);
                    letterImage = letterImage > 0;
                    letterImage = letterImage * letterLabel;

                    cols = letterbox(1):(letterbox(1) + letterbox(3));
                    rows = letterbox(2):(letterbox(2) + letterbox(4));

                    compositedLetters(rows,cols) = letterImage;
                    
                    % figure
                    % imshow(letterImage)

                    letterLabel = letterLabel + 1;
                end
            end

            
            % figure
            % imshow(label2rgb(compositedLetters,'jet','black','shuffle'));

            % Teraz trzeba coś zrobić z kropkami

            lines = label2rgb(compositedLetters,'jet','black','shuffle');



        end

    end


    methods
        function resultImage = separate(obj, originalImage, separatorValues)
            
            % if something goes wrong you'll get zeros 
            % in the separatorValues cell array (but it shouldn't lol)

            % for now it'll be easier for you to edit what you get if you
            % get a whole cell array, but once you tell me exactly what fields
            % you'd like to have, then you won't have to map like this:

            slider1_value = separatorValues{1};
            slider2_value = separatorValues{2};
            dropdown_value = separatorValues{3};
            checkbox_value = separatorValues{4};


            im = imread(originalImage);

            % Przekaż obraz do algorytmu odszumiającego, parametr określa
            % agresję odszumiania
            thick = TextSeparator.preprocess(im, separatorValues(1,1));

            

            
            
            % figure;
            % imshow(thick)

            figure
            imshow(thick);

            boxes = cat(1,regionprops(thick, 'BoundingBox').BoundingBox);
      
            % figure;
            
            % Potem dla każdego paragrafu tekstu, pętla
            paragraph = 1;
            
            % Wytnij paragraf
            im2 = imcrop(imfiltered, boxes(paragraph, :));

            % Przetwarza jeden paragraf tekstu, przyjmuje obraz binarny
            % jako wejscie
            improcess = TextSeparator.paragraphProcess(im2);

            % define return value (should probably return this and a 2d array 
            % of letter images?)
            resultImage = improcess;
            
        end
    end
end