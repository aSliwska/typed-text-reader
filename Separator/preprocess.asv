function [imresult, imbin] = preprocess(image, agresjaFiltrowania, agresjaMergeowania, czuloscSegmentacji, dodatkowaSegmentacja)

        close all

        % Przenieś obraz na odcienie szarości
        im = rgb2gray(image) ;

        if (agresjaFiltrowania < 5)
            agresjaFiltrowania = 5;
        end
        
        

        agresjaFiltrowania = ceil(agresjaFiltrowania / 100 * 4);

        
        % Odszumianie w dziedzinie obrazu skali szarości
        % im = medfilt2(im);

        % figure;
        % imshow(edges)

        im = imadjust(im);
        
        % figure
        % imshow(im)
        
        % Progowanie adaptacyjne daje lepsze wyniki dla zanieczyszczonego tekstu
        T = adaptthresh(im, 0.85, 'NeighborhoodSize', 55);
        im = ~imbinarize(im,T);
        
        % Wstępne odszumianie i usuwanie artefaktów
        im = imclearborder(im);
        im = imclose(im, ones(agresjaFiltrowania));
        im = imopen(im, ones(agresjaFiltrowania));
        im = medfilt2(im);
        im = imclearborder(im);

        % figure
        % imshow(im)

        
        
        % Regionprops do ustalenia parametrów liter

        im = bwlabel(im);
        props = regionprops(im,'BoundingBox', 'Area');
       
        S = cat(1, props.BoundingBox);




        % Filtr zanieczyszczen - usuwa obszary o polu znacznie mniejszym od
        % pola sredniej litery, kropki srednio nie wchodza w ta kategorie
        P = cat(1, props.Area);
        meanP = mean(P);
        devP = std(P);
        outlier = (P - meanP)./ devP;
        outidx = find(outlier < -2.5);
        im(ismember(im,outidx)) = 0;
        im = (im > 0);


        meanH = round(mean(S(:,4)));

        mergeCoeff = round(meanH / 4 * (agresjaMergeowania / 100));

        if (mergeCoeff > 1)
            im = imdilate(im, ones(mergeCoeff));
        end

        % Drugi pass, trzeba znaleźć obiekty które odstają
        % wielkością/innymi parametrami od liter i jeszcze raz
        % przeprowadzić na tych obszarach segmentację (aby np. pozbyć się
        % wieloznaków, nie wszystkich ale części)
        
        im = bwlabel(im > 0);

        props = regionprops(im, 'BoundingBox');
        boxes = cat(1, props.BoundingBox);
        widths = cat(1, props.BoundingBox);
        widths = widths(:, 3);


        meanWidths = mean(widths);
        devWidths = std(widths);
        outlier = (widths - meanWidths)./ devWidths;
        outlier = (outlier > 1.5);

        for i = 1:size(outlier,1)
            if (outlier(i) == 1)

                box = boxes(i,:);
                originalImageSample = rgb2gray(imcrop(image, box));

                filtSize = ceil(size(originalImageSample,2));

                if (mod(filtSize,2) == 0)
                    filtSize = filtSize - 1;
                end

                T = adaptthresh(originalImageSample, 0.95, 'NeighborhoodSize', filtSize);
                originalImageSample = ~imbinarize(originalImageSample,T);

                originalImageSample = imopen(originalImageSample, ones(agresjaFiltrowania));



                startingX = ceil(box(2));
                startingY = ceil(box(1));

                widthX = startingX + size(originalImageSample, 1) - 1;
                widthY = startingY + size(originalImageSample, 2) - 1;

                originalImageSample = imclose(originalImageSample, ones(mergeCoeff));


                im(startingX:widthX, startingY:widthY) = bwmorph(originalImageSample, "thicken", mergeCoeff);

                % figure
                % imshow(originalImageSample)

            end

        end

        im = im > 0;

        % Wieloznaki po części wyfiltrowane, do szukania bardziej
        % wyrafinowanych przypadków potrzebna byłaby sieć neuronowa



        figure
        imshow(im);


        imbin = im;

        % return;

        % figure
        % imshow(imbin);
        % figure

        
        
        % figure
        % imshow(im)

        % Wydobycie paragrafów tekstu z obrazka (nowy parametr?)

        thick = bwmorph(im, 'thicken', round(meanH / 2));
        thick = imfill(thick, "holes");
        thick = imclose(thick, ones(round(meanH)));
        thick = imfill(thick, "holes");

        thick = imclearborder(thick);
        
        imresult = thick;
        
        
        end
